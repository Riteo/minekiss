#! /bin/sh

# TODO: Add some good error handling where needed
# TODO: Properly manage native libraries by extracting them (https://wiki.vg/Game_Files)
# TODO: Properly manage legacy and pre-1.6 assets
# TODO: Add a rule reading system
# TODO: Add some primitive instance metadata reading
# TODO: Add a newinstance command
# TODO: Detect remote assets changes by looking at the asset index for a faster startup
# TODO: Find a portable way of switching java versions or at least find a way to configure them
# TODO: Refactor everything

# Bruh
export LC_ALL="C"

get_relative_resource_path() {
 printf "$(printf "%s" "$1" | head -c 2)/$1"
}

get_resource_url() {
	printf "$RESOURCES_URL/$(get_relative_resource_path "$1")"
}

parse_libraries_from_metadata() {
	# Here the -c flag is important since we want to parse a line as an object.
	# Also, how the fuck do I split this.
	jq -rc ".libraries[] | select((has(\"rules\") | not) or .rules[0].action == \"allow\" and .rules[0].os.name != \"osx\") | .downloads.classifiers.\"natives-linux\" // empty, .downloads.artifact // empty"
}

error() {
	printf "X $1\n"
	exit 1
}

info() {
	printf -- "-> $1\n"
}

warning() {
	printf "! $1\n"
}

cleanup() {
	info "Cleaning up..."
	rm -rf "$TEMP_DIR"
}

download() {
	SELECTED_VERSION="$1"

	VERSION_CLIENT_FILE="$VERSIONS_DIR/$SELECTED_VERSION/$SELECTED_VERSION.jar"
	VERSION_METADATA_FILE="$VERSIONS_DIR/$SELECTED_VERSION/$SELECTED_VERSION.json"

	VERSION_MANIFEST_FILE="$CACHE_DIR/version_manifest.json"
	ASSET_INDEX_FILE="$ASSETS_DIR/indexes/$SELECTED_VERSION.json"

	info "Fetching the latest version manifest..."

	mkdir -p "$(dirname "$VERSION_MANIFEST_FILE")"
	curl -s "$VERSION_MANIFEST_URL" > "$VERSION_MANIFEST_FILE" || error "Unable to fetch the latest manifest!"
	
	VERSION_METADATA_URL="$(jq -r ".versions[] | select(.id == \"$SELECTED_VERSION\").url" < "$VERSION_MANIFEST_FILE")"

	if [ "$VERSION_METADATA_URL" == "" ]
	then
			error "Invalid version id!"
	fi

	if [ -f "$VERSION_METADATA_FILE" ]
	then
		info "Validating the current version metadata..."

		# The SHA1 is for some reason only encoded into the version metadata path.
		# URL format: https://launchermeta.mojang.com/v1/packages/SHA/VERSION.json
		VERSION_METADATA_SHA1="$(basename "$(dirname "$VERSION_METADATA_URL")")"

		printf "%s  %s\n" "$VERSION_METADATA_SHA1" "$VERSION_METADATA_FILE" | sha1sum -c 1>/dev/null 2>&1

		if [ $? != 0 ]
		then
			info "Validation failed! Redownloading..."
			curl -s "$VERSION_METADATA_URL" > "$VERSION_METADATA_FILE"
		fi
	else
		info "Fetching the version metadata file..."
		mkdir -p "$(dirname "$VERSION_METADATA_FILE")"
		curl -s "$VERSION_METADATA_URL" > "$VERSION_METADATA_FILE"
	fi

	VERSION_CLIENT_URL="$(jq -r ".downloads.client.url" < "$VERSION_METADATA_FILE")"

	if [ -f "$VERSION_CLIENT_FILE" ]
	then
		info "Validating the client jar..."

		VERSION_CLIENT_SHA1="$(jq -r ".downloads.client.sha1" < "$VERSION_METADATA_FILE")"

		printf "%s  %s\n" "$VERSION_CLIENT_SHA1" "$VERSION_CLIENT_FILE" | sha1sum -c 1>/dev/null 2>&1

		if [ $? != 0 ]
		then
			info "Validation failed! Redownloading..."
			curl -s "$VERSION_CLIENT_URL" > "$VERSION_CLIENT_FILE"
		fi
	else
		info "Downloading the client jar..."
		# We don't run mkdir here because the client will be downloaded in the same
		# directory of the version metadata.
		curl -s "$VERSION_CLIENT_URL" > "$VERSION_CLIENT_FILE"
	fi

	ASSET_INDEX_URL="$(jq -r ".assetIndex.url" < "$VERSION_METADATA_FILE")"

	if [ -f "$ASSET_INDEX_FILE" ]
	then
		info "Validating the game's asset index..."

		ASSET_INDEX_SHA1="$(jq -r ".assetIndex.sha1" < "$VERSION_METADATA_FILE")"

		printf "%s  %s\n" "$ASSET_INDEX_SHA1"  "$ASSET_FILE" | sha1sum -c 1>/dev/null 2>&1

		if [ $? == 0 ]
		then
			info "Validation failed! Redownloading..."
			curl -s "$ASSET_INDEX_URL" > "$ASSET_INDEX_FILE"
		fi
	else
		info "Downloading the game's asset index..."

		mkdir -p "$(dirname $ASSET_INDEX_FILE)"
		curl -s "$ASSET_INDEX_URL" > "$ASSET_INDEX_FILE"
	fi

	# TODO: Add support for the older asset indexes.
	info "Validating the game's assets..."

	CONVERTED_ASSET_INDEX="$TEMP_DIR/converted_asset_index"
	FAILED_ASSETS="$TEMP_DIR/failed_assets"

	# Le epic conversion: [le hash] [le actual path] [le game path]
	# This allows us to use the shell's own word splitting as a blazingly fast line
	# by line "parser" for our intermediate format. Maybe we could use FIFOs but I
	# think that would just make things more complicated for nothing.
	jq -r ".objects | to_entries[] | .value.hash + \" \" + \"$ASSETS_DIR/objects/\" + .value.hash[0:2] + \"/\" + .value.hash + \" \" + .key" < "$ASSET_INDEX_FILE" > "$CONVERTED_ASSET_INDEX"

	awk '{print $1 "  " $2}' < "$CONVERTED_ASSET_INDEX" | sha1sum -c 2> /dev/null | grep FAILED | cut -d ":" -f 1 > "$FAILED_ASSETS"


	grep -f "$FAILED_ASSETS" < "$CONVERTED_ASSET_INDEX" | while read -r ASSET_SHA1 ASSET_FILE_PATH ASSET_GAME_PATH
	do
		info "Downloading \"$ASSET_GAME_PATH\"..."
		mkdir -p "$(dirname "$ASSET_FILE_PATH")"
		curl -s "$(get_resource_url "$ASSET_SHA1")" > "$ASSET_FILE_PATH"
	done

	info "Validating the game's libraries..."

	# TODO: Decompress properly the native libraries into a specialized directory.
	# TODO: Make the parsing faster and cleaner using an approach similar to the
	# above.
	parse_libraries_from_metadata < "$VERSION_METADATA_FILE" | while read -r ARTIFACT_OBJECT
	do
		LIBRARY_RELATIVE_PATH="$(printf "%s" "$ARTIFACT_OBJECT" | jq -r ".path")"
		LIBRARY_SHA1="$(printf "%s" "$ARTIFACT_OBJECT" | jq -r ".sha1")"

		LIBRARY_FILE_NAME="$(basename "$LIBRARY_RELATIVE_PATH")"

		LIBRARY_FILE="$LIBRARIES_DIR/$LIBRARY_RELATIVE_PATH"
		mkdir -p "$(dirname "$LIBRARY_FILE")"

		LIBRARY_URL="$(printf "%s" "$ARTIFACT_OBJECT" | jq -r ".url")"

		if [ -f "$LIBRARY_FILE" ]
		then
			info "Validating \"$LIBRARY_FILE_NAME\"..."

			LIBRARY_CURRENT_SHA1="$(sha1sum "$LIBRARY_FILE" | cut -d " " -f 1)"

			if [ "$LIBRARY_CURRENT_SHA1" != "$LIBRARY_SHA1" ]
			then
				info "Redownloading \"$LIBRARY_FILE_NAME\"..."
				curl -s "$LIBRARY_URL" > "$LIBRARY_FILE"
			fi
		else
			info "Downloading \"$LIBRARY_FILE_NAME\"..."
			curl -s "$LIBRARY_URL" > "$LIBRARY_FILE"
		fi
	done
}

start() {
	SELECTED_VERSION="$1"

	VERSION_CLIENT_FILE="$VERSIONS_DIR/$SELECTED_VERSION/$SELECTED_VERSION.jar"
	VERSION_METADATA_FILE="$VERSIONS_DIR/$SELECTED_VERSION/$SELECTED_VERSION.json"

	if [ ! -f "$VERSION_METADATA_FILE" ]
	then
		error "No such version downloaded."
	fi

	CLASSPATH="$(parse_libraries_from_metadata < "$VERSION_METADATA_FILE" | jq -r "\"$LIBRARIES_DIR/\" + .path" | tr "\n" ":")"
	CLASSPATH="$CLASSPATH$VERSION_CLIENT_FILE"

	MAIN_CLASS="$(jq -r ".mainClass" < "$VERSION_METADATA_FILE")"
	ASSET_INDEX_ID="$(jq -r ".assetIndex.id" < "$VERSION_METADATA_FILE")"

	# TODO: Find a way to manage stuff like resolution which is behind a rule.
	# TODO: Manage legacy version support properly (the current solution doesn't work).
	GAME_ARGUMENTS="$(echo $(jq -r "if has(\"arguments\") and (.arguments | has(\"game\")) then (.arguments.game[] | strings) else .minecraftArguments end" < "$VERSION_METADATA_FILE" | tr "\n" " "))"
	GAME_ARGUMENTS="$(printf "%s" "$GAME_ARGUMENTS" | sed "s|"'${version_name}'"|$SELECTED_VERSION|")"
	GAME_ARGUMENTS="$(printf "%s" "$GAME_ARGUMENTS" | sed "s|"'${assets_root}'"|$ASSETS_DIR|")"
	GAME_ARGUMENTS="$(printf "%s" "$GAME_ARGUMENTS" | sed "s|"'${assets_index_name}'"|$ASSET_INDEX_ID|")"

	# Compat option
	GAME_ARGUMENTS="$(printf "%s" "$GAME_ARGUMENTS" | sed "s|"'${game_assets}'"|$ASSETS_DIR/virtual/$ASSET_INDEX_ID/|")"

	if [ "$JAVA" == "" ]
	then
		JAVA="java"
	fi

	# TODO: Read metadata from the instance to choose the java version
	# TODO: Pass the (properly formatted) game arguments
	"$JAVA" -cp "$CLASSPATH" "$MAIN_CLASS" $GAME_ARGUMENTS
}

# Configuration

if [ "$VERSION_MANIFEST_URL" == "" ]
then
	VERSION_MANIFEST_URL="https://launchermeta.mojang.com/mc/game/version_manifest.json"
fi

if [ "$RESOURCE_URL" == "" ]
then
	RESOURCES_URL="http://resources.download.minecraft.net"
fi

if [ "$XDG_CACHE_HOME" == "" ]
then
	XDG_CACHE_HOME="$HOME/.cache"
fi

CACHE_DIR="$XDG_CACHE_HOME/minekiss"

if [ "$ASSETS_DIR" == "" ]
then
	ASSETS_DIR="$CACHE_DIR/assets"
fi

if [ "$LIBRARIES_DIR" == "" ]
then
	LIBRARIES_DIR="$CACHE_DIR/libraries"
fi

if [ "$VERSIONS_DIR" == "" ]
then
	VERSIONS_DIR="$CACHE_DIR/versions"
fi

if [ "$TEMP_DIR" == "" ]
then
	TEMP_DIR="/tmp/minekiss"
fi

mkdir "$TEMP_DIR"

trap exit INT
trap cleanup EXIT

if [ "$1" == "download" ]
then
	if [ "$2" != "" ]
	then
		download "$2" && info "Download finished."
	else
		printf "Usage: $0 download ID\n"
		printf "Downloads and verifies the specified mincraft version into minekiss' cache directory.\n"
	fi
	exit 0
fi

if [ "$1" == "start" ]
then
	if [ "$2" != "" ]
	then
		start "$2"
else
		printf "Usage: $0 start ID\n"
		printf "start: Runs the specified minecraft version (if dowloaded) into the current drectory.\n"
	fi
	exit 0
fi

if [ "$1" != "" ]
then
	printf "Unrecognized command: \"$1\"\n"
else
	printf "minekiss - A simple minecraft launcher written entirely in POSIX shell.\n"
	printf "Available commands:\n"
	printf " - download: Downloads and verifies the specified minecraft version into minekiss' cache directory.\n"
	printf " - start: Runs the specified minecraft version (if dowloaded) into the current drectory.\n"
fi
exit 0


