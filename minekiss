#! /bin/sh

# TODO: Properly manage missing accounts and invalid tokens
# TODO: Have an idea of what to do with multiple downloading instances
# TODO: Properly parse all library and jvm rules
# TODO: Add an offline mode
# TODO: Add some more error handling
# TODO: Properly manage pre-1.6 assets
# TODO: Find a portable way of switching Java versions or at least find a way to configure them
# TODO: Remove all platform-specific stuff, detect the current OS and set all rules properly.

# Bruh
export LC_ALL="C"

OLD_STTY="$(stty -g)"

is_directory_empty() {
	# This implmentation avoids ls and passes shellcheck through globbing.
	# I feel like it could be simpler though.
	test "$(printf "%s" "$1"/*)" = "$1/*"
}

get_relative_resource_path() {
	printf "%s\n" "$(printf "%s" "$1" | head -c 2)/$1"
}

get_resource_url() {
	printf "%s\n" "$MINEKISS_RESOURCES_URL/$(get_relative_resource_path "$1")"
}

get_library_index_from_metadata_file() {
	# Format: [path] [sha1sum] [url]
	# Apparently we can avoid the whole "exclude" rule as it seems to do pretty
	# marginal stuff for now.
	jq -r ".libraries[]
	| select((has(\"rules\") | not) or .rules[0].action == \"allow\" and .rules[0].os.name != \"osx\")
	| .downloads.classifiers.\"natives-linux\" // .downloads.artifact // empty
	| \"$MINEKISS_LIBRARIES_DIR/\" + .path + \" \" + .sha1 + \" \" + .url" "$1"

	# Maven library support

	jq -r '.libraries[] | select(has("name") and has("url")) | .name + " " + .url' $1 | while read PACKAGE REPO_URL
	do
		RELATIVE_LIBRARY_PATH="$(printf "%s" "$PACKAGE" | {
			IFS=":" read NAMESPACE NAME VERSION
			printf "%s\n" "$(printf "%s" "$NAMESPACE" | tr "." "/")/$NAME/$VERSION/$NAME-$VERSION.jar"
		})"

		LOCAL_LIBRARY_PATH="$MINEKISS_LIBRARIES_DIR/$RELATIVE_LIBRARY_PATH"
		REMOTE_LIBRARY_PATH="$REPO_URL/$RELATIVE_LIBRARY_PATH"

		# TODO: Multiple downloads to avoid multiple handshakes.
		LIBRARY_SHA1="$(curl -s "$REMOTE_LIBRARY_PATH.sha1")"

		printf "%s\n" "$LOCAL_LIBRARY_PATH $LIBRARY_SHA1 $REMOTE_LIBRARY_PATH"
	done
}

error() {
	printf -- "$ERROR_FORMAT"  "$1" >&2
	exit 1
}

info() {
	printf -- "$INFO_FORMAT" "$1"
}

warning() {
	printf -- "$WARNING_FORMAT" "$1" >&2
}

prompt() {
	printf "$PROMPT_FORMAT" "$1"
	read -r "$2"
}

prompt_hidden() {
	# We don't want to write the password to the terminal.
	stty -echo
	printf '\033[32;1m<-\033[m %s ' "$1"
	read -r "$2"
	stty echo
	printf "\n"
}

abort() {
	stty "$OLD_STTY"
	printf "\n"

	error "Aborted."
}

cleanup() {
	if [ "$MINEKISS_DEBUG" == "" ]
	then
		if ! is_directory_empty "$MINEKISS_TEMP_DIR"
		then info "Cleaning up..."
		fi

		rm -rf "$MINEKISS_TEMP_DIR"
	fi
}

refresh_token() {
	curl -s -H "Content-Type: application/json" -d \
	"{
		\"accessToken\": \"$1\",
		\"clientToken\": \"$(cat "$USERDATA_DIR/client_id")\"
	}" "$MINEKISS_AUTH_SERVER_URL/refresh" | jq -r "
		if has(\"accessToken\")
		then .accessToken
		else \"\" | halt_error(1)
		end"
	return
}

# TODO: Add a latest and latest-snapshot option.
# TODO: Infer "latest" from an empty argument, add a version
# preference/variable or simply throw an error.
download() {
	SELECTED_VERSION="$1"

	SELECTED_VERSION_DIR="$MINEKISS_VERSIONS_DIR/$SELECTED_VERSION"
	VERSION_CLIENT_FILE="$SELECTED_VERSION_DIR/$SELECTED_VERSION.jar"
	VERSION_METADATA_FILE="$SELECTED_VERSION_DIR/$SELECTED_VERSION.json"

	VERSION_MANIFEST_FILE="$CACHE_DIR/version_manifest.json"

	VERSION_INHERITS="$(jq -r ".inheritsFrom // empty" "$VERSION_METADATA_FILE")"

	# We clean this variable in case the function is being called from itself.
	# We could be cleaner regarding variable setting in general though.
	CUSTOM_VERSION=""

	info "Fetching the latest version manifest..."

	mkdir -p "$(dirname "$VERSION_MANIFEST_FILE")"
	curl -s "$MINEKISS_MANIFEST_URL" > "$VERSION_MANIFEST_FILE" || error "Unable to fetch the latest manifest!"
	
	VERSION_METADATA_URL="$(jq -r ".versions[] | select(.id == \"$SELECTED_VERSION\").url" "$VERSION_MANIFEST_FILE")"

	if [ "$VERSION_METADATA_URL" = "" ]
	then
		if [ -f "$VERSION_METADATA_FILE" ]
		then
			warning "Custom version detected!"
			CUSTOM_VERSION=1

			if [ "$VERSION_INHERITS" != "" ]
			then
				info "Version inherits from $VERSION_INHERITS, downloading it first..."
				(download "$VERSION_INHERITS" > /dev/null)
				ln -sf "$MINEKISS_VERSIONS_DIR/$VERSION_INHERITS/$VERSION_INHERITS.jar" "$SELECTED_VERSION_DIR/$SELECTED_VERSION.jar"
			fi
		else
			error "Invalid version id!"
		fi
	fi

	# We merge the inherited json with its parent to avoid writing specific code.
	#
	# NOTE: This is a very basilar and primitive merge. Further tweakings or more
	# sofisticated code may be needed,
	if [ "$VERSION_INHERITS" != "" ]
	then
		jq --slurpfile parent "$MINEKISS_VERSIONS_DIR/$VERSION_INHERITS/$VERSION_INHERITS.json" \
		'$parent[0] * (setpath(["libraries"];$parent[0].libraries + .libraries)
			| setpath(["arguments","game"];$parent[0].arguments.game + .arguments.game))' \
		"$VERSION_METADATA_FILE" > "$MINEKISS_TEMP_DIR/mergedmanifest.json"
		VERSION_METADATA_FILE="$MINEKISS_TEMP_DIR/mergedmanifest.json"
	fi

	if [ "$CUSTOM_VERSION" == "" ]
	then
		# Metadata
		info "Validating the current version metadata..."

		# The SHA1 is for some reason only encoded into the version metadata path.
		# URL format: https://launchermeta.mojang.com/v1/packages/SHA/VERSION.json
		VERSION_METADATA_SHA1="$(basename "$(dirname "$VERSION_METADATA_URL")")"

		if ! printf "%s  %s\n" "$VERSION_METADATA_SHA1" "$VERSION_METADATA_FILE" | sha1sum -c 1>/dev/null 2>&1
		then
			info "Downloading \"$(basename "$VERSION_METADATA_FILE")\"..."
			mkdir -p "$(dirname "$VERSION_METADATA_FILE")"
			curl -s "$VERSION_METADATA_URL" > "$VERSION_METADATA_FILE"

			# Client
			VERSION_CLIENT_URL="$(jq -r ".downloads.client.url" < "$VERSION_METADATA_FILE")"

			info "Validating the client jar..."

			VERSION_CLIENT_SHA1="$(jq -r ".downloads.client.sha1" < "$VERSION_METADATA_FILE")"

			if ! printf "%s  %s\n" "$VERSION_CLIENT_SHA1" "$VERSION_CLIENT_FILE" | sha1sum -c 1>/dev/null 2>&1
			then
				info "Downloading \"$(basename "$VERSION_CLIENT_FILE")\"..."
				# We don't run mkdir here because the client will be downloaded in the same
				# directory of the version metadata.
				curl -s "$VERSION_CLIENT_URL" > "$VERSION_CLIENT_FILE"
			fi

			# Asset index
			info "Validating the game's asset index..."

			ASSET_INDEX_ID="$(jq -r ".assetIndex.id" < "$VERSION_METADATA_FILE")"
			ASSET_INDEX_URL="$(jq -r ".assetIndex.url" < "$VERSION_METADATA_FILE")"
			ASSET_INDEX_SHA1="$(jq -r ".assetIndex.sha1" < "$VERSION_METADATA_FILE")"

			ASSET_INDEX_FILE="$MINEKISS_ASSETS_DIR/indexes/$ASSET_INDEX_ID.json"

			if ! printf "%s  %s\n" "$ASSET_INDEX_SHA1" "$ASSET_INDEX_FILE" | sha1sum -c 1>/dev/null 2>&1
			then
				info "Downloading \"$(basename "$ASSET_INDEX_FILE")\"..."

				mkdir -p "$(dirname "$ASSET_INDEX_FILE")"
				curl -s "$ASSET_INDEX_URL" > "$ASSET_INDEX_FILE"
			fi

			# TODO: Add support for the older asset indexes.
			info "Validating the game's assets..."

			if [ "$ASSET_INDEX_ID" = "pre-1.6" ]
			then
				error "Pre 1.6 version detected! Download stopped as legacy asset managing is not supported yet."
			fi

			CONVERTED_ASSET_INDEX="$MINEKISS_TEMP_DIR/converted_asset_index"
			FAILED_ASSETS="$MINEKISS_TEMP_DIR/failed_assets"

			# Le epic conversion: [le hash] [le actual path] [le game path]
			# This allows us to use the shell's own word splitting as a blazingly fast line
			# by line "parser" for our intermediate format. Maybe we could use FIFOs but I
			# think that would just make things more complicated for nothing.
			jq -r ".virtual as \$virtual
			| .objects | to_entries[]
			| .value.hash
				+ \" \"
				+ (if \$virtual | not
					then
					\"$MINEKISS_ASSETS_DIR/objects/\" + .value.hash[0:2]+ \"/\" + .value.hash
					else
					\"$MINEKISS_ASSETS_DIR/virtual/$ASSET_INDEX_ID\" + \"/\" + .key
					end)
				+ \" \" + .key" < "$ASSET_INDEX_FILE" > "$CONVERTED_ASSET_INDEX"

			awk '{print $1 "  " $2}' < "$CONVERTED_ASSET_INDEX" | sha1sum -c 2> /dev/null | grep FAILED | cut -d ":" -f 1 > "$FAILED_ASSETS"

			grep -f "$FAILED_ASSETS" < "$CONVERTED_ASSET_INDEX" | while read -r ASSET_SHA1 ASSET_FILE_PATH ASSET_GAME_PATH
			do
				info "Downloading \"$ASSET_GAME_PATH\"..."
				mkdir -p "$(dirname "$ASSET_FILE_PATH")"
				curl -s "$(get_resource_url "$ASSET_SHA1")" > "$ASSET_FILE_PATH"
			done
		fi
	fi

	# Libaries
	info "Validating the game's libraries..."

	CONVERTED_LIBRARY_INDEX="$MINEKISS_TEMP_DIR/converted_library_index"
	FAILED_LIBS="$MINEKISS_TEMP_DIR/failed_libs"

	get_library_index_from_metadata_file "$VERSION_METADATA_FILE" > "$CONVERTED_LIBRARY_INDEX"

	awk '{print $2 "  " $1}' < "$CONVERTED_LIBRARY_INDEX" | sha1sum -c 2> /dev/null | grep FAILED | cut -d ":" -f 1 > "$FAILED_LIBS"

	# It's easier to keep that LIBRARY_SHA1 for parsing purposes.
	# I prefer keeping the name for readibility though, that's why we have to
	# disable this check.
	# shellcheck disable=SC2034
	grep -f "$FAILED_LIBS" < "$CONVERTED_LIBRARY_INDEX" | while read -r LIBRARY_FILE LIBRARY_SHA1 LIBRARY_URL
	do
		LIBRARY_FILE_NAME="$(basename "$LIBRARY_FILE")"
		mkdir -p "$(dirname "$LIBRARY_FILE")"

		info "Downloading \"$LIBRARY_FILE_NAME\"..."

		curl -s "$LIBRARY_URL" > "$LIBRARY_FILE"
	done

	info "Validating the version's native libraries..."

	mkdir -p "$SELECTED_VERSION_DIR/lib"
	cat "$CONVERTED_LIBRARY_INDEX" | grep "native" | while read -r LIBRARY_FILE LIBRARY_SHA1 LIBRARY_URL
	do
		LIBRARY_FILE_NAME="$(basename "$LIBRARY_FILE")"
		LIBRARY_DIRECTORY="$(dirname "$LIBRARY_FILE")"

		mkdir -p "$LIBRARY_DIRECTORY/native"

		for NATIVE_LIBRARY_FILE_NAME in $(zipinfo -1 $LIBRARY_FILE -x 'META-INF/*' '*.git' '*.sha1' 2> /dev/null)
		do
			# We fetch the first matching element and work on that, otherwise any other
			# similarly named file might get stuck there forever.
			CHECKSUMMED_NATIVE_LIBRARY_FILE="$(printf "%s " $LIBRARY_DIRECTORY/native/$NATIVE_LIBRARY_FILE_NAME.* | cut -d " " -f 1)"
			CHECKSUMMED_NATIVE_LIBRARY_FILE_NAME="$(basename "$CHECKSUMMED_NATIVE_LIBRARY_FILE")"

			NATIVE_LIBRARY_FILE_SHA1="${CHECKSUMMED_NATIVE_LIBRARY_FILE_NAME##*.}"
			NATIVE_LIBRARY_FILE_CURRENT_SHA1="$(sha1sum "$CHECKSUMMED_NATIVE_LIBRARY_FILE" | cut -d ' ' -f 1)"

			NATIVE_LIBRARY_LINK="$SELECTED_VERSION_DIR/lib/$NATIVE_LIBRARY_FILE_NAME"

			# We steer off a bit from the traditional native library management by
			# storing each decompressed library into a folder with its checksum
			# appended to its name. We then parse it to get its original checksum
			# and compare it.
			# Thanks to Dylan Araps for this great idea.
			if [ "$NATIVE_LIBRARY_FILE_CURRENT_SHA1" != "$NATIVE_LIBRARY_FILE_SHA1" ]
			then
				rm -f "$CHECKSUMMED_NATIVE_LIBRARY_FILE"
				info "Extracting \"$NATIVE_LIBRARY_FILE_NAME\"..."
				(cd "$LIBRARY_DIRECTORY/native"
				unzip -qqo "$LIBRARY_FILE" "$NATIVE_LIBRARY_FILE_NAME"
				NATIVE_LIBRARY_FILE_SHA1="$(sha1sum "$NATIVE_LIBRARY_FILE_NAME" | cut -d ' ' -f 1)"
				CHECKSUMMED_NATIVE_LIBRARY_FILE="$LIBRARY_DIRECTORY/native/$NATIVE_LIBRARY_FILE_NAME.$NATIVE_LIBRARY_FILE_SHA1"
				mv "$NATIVE_LIBRARY_FILE_NAME" "$CHECKSUMMED_NATIVE_LIBRARY_FILE")
			fi

			if [ ! -f "$NATIVE_LIBRARY_LINK" ]
			then
				ln -sf "$CHECKSUMMED_NATIVE_LIBRARY_FILE" "$NATIVE_LIBRARY_LINK"
			fi
		done
	done
}

start_version() {
	SELECTED_VERSION="$1"

	VERSION_CLIENT_FILE="$MINEKISS_VERSIONS_DIR/$SELECTED_VERSION/$SELECTED_VERSION.jar"
	VERSION_METADATA_FILE="$MINEKISS_VERSIONS_DIR/$SELECTED_VERSION/$SELECTED_VERSION.json"

	download "$SELECTED_VERSION"

	CLASSPATH="$(get_library_index_from_metadata_file "$VERSION_METADATA_FILE" | awk '{print $1}' | tr "\n" ":")"
	CLASSPATH="$CLASSPATH$VERSION_CLIENT_FILE"

	MAIN_CLASS="$(jq -r ".mainClass" < "$VERSION_METADATA_FILE")"
	ASSET_INDEX_ID="$(jq -r ".assetIndex.id" < "$VERSION_METADATA_FILE")"

	# Authentication
	SELECTED_ACCOUNT="$(cat "$USERDATA_DIR/selected_account")"
	SELECTED_ACCOUNT_DIR="$USERDATA_DIR/accounts/$SELECTED_ACCOUNT"
	SELECTED_UUID="$(cat "$SELECTED_ACCOUNT_DIR/profiles/selected_uuid")"
	SELECTED_USERNAME="$(cat "$SELECTED_ACCOUNT_DIR/profiles/$SELECTED_UUID")"
	AUTH_TOKEN="$(cat "$SELECTED_ACCOUNT_DIR/auth_token")"

	if ! token_is_valid "$AUTH_TOKEN"
	then
		REFRESH_RESULT="$(refresh_token "$AUTH_TOKEN")"
		if [ "$?" != 0 ]
		then
			warning "Invalid auth token: access required."
			account_login "$SELECTED_ACCOUNT"
		fi
	fi

	# TODO: Find a way to manage stuff like resolution which is behind a rule.
	# TODO: Format all arguments.
	GAME_ARGUMENTS="$(jq -r "if has(\"arguments\") and (.arguments | has(\"game\")) then (.arguments.game[] | strings) else .minecraftArguments end" < "$VERSION_METADATA_FILE" | tr "\n" " ")"

	GAME_ARGUMENTS="$(printf "%s\n" "$GAME_ARGUMENTS" \
	| sed "s|\${version_name}|$SELECTED_VERSION|" \
	| sed "s|\${assets_root}|$MINEKISS_ASSETS_DIR|" \
	| sed "s|\${assets_index_name}|$ASSET_INDEX_ID|" \
	| sed "s|\${version_type}|$(jq -r .type < "$VERSION_METADATA_FILE")|" \
	| sed "s|\${game_directory}|$MINEKISS_GAME_DIRECTORY|" \
	| sed "s|\${user_properties}|{}|" \
	| sed "s|\${auth_uuid}|$SELECTED_UUID|" \
	| sed "s|\${auth_access_token}|$AUTH_TOKEN|" \
	| sed "s|\${auth_player_name}|$SELECTED_USERNAME|")"

	# Legacy argument formatting for compatibility.
	GAME_ARGUMENTS="$(printf "%s\n" "$GAME_ARGUMENTS" \
	| sed "s|\${auth_session}|$AUTH_TOKEN|")"

	# Virtual assets support
	if jq -e .virtual "$MINEKISS_ASSETS_DIR/indexes/$ASSET_INDEX_ID.json" > /dev/null
	then
		GAME_ARGUMENTS="$(printf "%s\n" "$GAME_ARGUMENTS" \
		| sed "s|\${game_assets}|$MINEKISS_ASSETS_DIR/virtual/$ASSET_INDEX_ID|")"
	fi

	# TODO: Find out if there's a better way to switch Java runtimes.
	if [ "$JAVA" = "" ]
	then
		JAVA="java"
	fi

	# TODO: Read metadata from the instance to choose the right Java version.
	# We need word splitting because the arguments are dynamically specified
	# in the version manifest.
	# TODO: Format the JVM's arguments.
	# shellcheck disable=SC2086
	"$JAVA" -Djava.library.path="$MINEKISS_VERSIONS_DIR/$SELECTED_VERSION/lib" -cp "$CLASSPATH" $MAIN_CLASS $GAME_ARGUMENTS
}

# NOTE: This as of now just returns the only select profile (if any) as i'll
#       still have to implement Microsoft login properly when it becomes more
#       widespread. This will suffice for now.
#
# FORMAT: [ACCESS TOKEN] [PROFILE NAME] [PROFILE UUID]
authenticate_account() {
	curl -s --fail-with-body -H "Content-Type: application/json" -d \
	"{
		\"agent\": {
			\"name\": \"Minecraft\",
			\"version\": 1
		},
		\"username\": \"$1\",
		\"password\": \"$2\",
		\"clientToken\": \"$(cat "$USERDATA_DIR/client_id")\"
	}" "$MINEKISS_AUTH_SERVER_URL"/authenticate | jq -r \
	"if has(\"accessToken\")
	then
		if (has(\"selectedProfile\"))
		then .accessToken + \" \" + (.selectedProfile | .name + \" \" + .id )
		else \"No Minecraft profile found.\" | halt_error(2)
		end
	else \"Authentication failed: \" + .errorMessage + \"\n\" | halt_error(1)
	end"
}

account_write() {
	EMAIL_ADDRESS="$1"
	AUTH_TOKEN="$2"
	PROFILE_NAME="$3"
	PROFILE_UUID="$4"

	ACCOUNT_DIR="$USERDATA_DIR/accounts/$EMAIL_ADDRESS"

	umask 077
	mkdir -p "$ACCOUNT_DIR/profiles"
	printf "%s\n" "$AUTH_TOKEN" > "$ACCOUNT_DIR/auth_token"
	printf "%s\n" "$PROFILE_NAME" > "$ACCOUNT_DIR/profiles/$PROFILE_UUID"
	printf "%s\n" "$PROFILE_UUID" > "$ACCOUNT_DIR/profiles/selected_uuid"
	printf "%s\n" "$EMAIL_ADDRESS" > "$USERDATA_DIR/selected_account"
}

token_is_valid() {
	curl -f -s -H "Content-Type: application/json" -d \
	"{
		\"accessToken\":\"$1\",
		\"clientToken\":\"$(cat "$USERDATA_DIR/client_id")\"
	}" "$MINEKISS_AUTH_SERVER_URL/validate"
}

token_invalidate() {
	curl -s -f -H "Content-Type: application/json" -d \
	"{
		\"accessToken\": \"$1\",
		\"clientToken\": \"$(cat "$USERDATA_DIR/client_id")\"
	}" "$MINEKISS_AUTH_SERVER_URL/invalidate"
}

account_login() {
	if [ ! "$1" ]
	then
		ACCOUNT="$(cat "$USERDATA_DIR/selected_account")"
	else
		ACCOUNT="$1"
	fi

	if [ "$ACCOUNT" == "" ]
	then
		prompt "Username:" ACCOUNT
		printf "%s\n" $ACCOUNT > "$USERDATA_DIR/selected_account"
	fi

	PASSWORD="$2"

	while true
	do
		prompt_hidden "Password for $ACCOUNT:" PASSWORD
		authenticate_account "$ACCOUNT" "$PASSWORD" | if read -r AUTH_TOKEN PROFILE_NAME PROFILE_UUID
		then account_write "$ACCOUNT" "$AUTH_TOKEN" "$PROFILE_NAME" "$PROFILE_UUID"
		else return 1 # We're inside a subshell due to the pipe
		fi && break
	done

	info "Authenticated successfully."
}

account_list() {
	if ! is_directory_empty "$USERDATA_DIR/accounts/"
	then
		printf "%s\n" "$USERDATA_DIR/accounts/"*/ 2>/dev/null | while read -r ACCOUNT
		do
			info "$(basename "$ACCOUNT")"
		done
	fi
}

account_logout() {
	if [ "$1" ]
	then
		ACCOUNT="$(cat "$USERDATA_DIR/selected_account")"
	else
		ACCOUNT="$1"
	fi

	ACCOUNT_PATH="$USERDATA_DIR/accounts/$ACCOUNT"

	if [ ! -d "$ACCOUNT_PATH" ]
		then error "Account not found."
	fi

	token_invalidate "$(cat "$ACCOUNT_PATH/auth_token")"
	rm -rf "$ACCOUNT_PATH"
}

account_select() {
	if [ "$1" ]
	then
		printf "%s\n" "$1" > "$USERDATA_DIR/selected_account"
	else
		SELECTED_ACCOUNT="$(cat "$USERDATA_DIR/selected_account")"

		if [ "$SELECTED_ACCOUNT" ]
		then
			info "Selected account: "$SELECTED_ACCOUNT""
		else
			info "No default account selected."
		fi
	fi
}

# Configuration

if [ "$XDG_CACHE_HOME" = "" ]
then
	XDG_CACHE_HOME="$HOME/.cache"
fi

CACHE_DIR="$XDG_CACHE_HOME/minekiss"

if [ "$XDG_DATA_HOME" = "" ]
then
	XDG_DATA_HOME="$HOME/.local/share"
fi

USERDATA_DIR="$XDG_DATA_HOME/minekiss"

if [ "$MINEKISS_MANIFEST_URL" = "" ]
then
	MINEKISS_MANIFEST_URL="https://launchermeta.mojang.com/mc/game/version_manifest.json"
fi

if [ "$MINEKISS_RESOURCES_URL" = "" ]
then
	MINEKISS_RESOURCES_URL="http://resources.download.minecraft.net"
fi

if [ "$MINEKISS_AUTH_SERVER_URL" = "" ]
then
	MINEKISS_AUTH_SERVER_URL="https://authserver.mojang.com"
fi

if [ "$MINEKISS_ASSETS_DIR" = "" ]
then
	MINEKISS_ASSETS_DIR="$CACHE_DIR/assets"
fi

if [ "$MINEKISS_LIBRARIES_DIR" = "" ]
then
	MINEKISS_LIBRARIES_DIR="$CACHE_DIR/libraries"
fi

if [ "$MINEKISS_VERSIONS_DIR" = "" ]
then
	MINEKISS_VERSIONS_DIR="$CACHE_DIR/versions"
fi

if [ "$MINEKISS_GAME_DIRECTORY" = "" ]
then
	MINEKISS_GAME_DIRECTORY="."
fi

if [ "$MINEKISS_TEMP_DIR" = "" ]
then
	MINEKISS_TEMP_DIR="/tmp/minekiss"
fi

if [ ! -f "$USERDATA_DIR/client_id" ]
then (umask 077; uuidgen > "$USERDATA_DIR/client_id")
fi

if [ -t 1 ]
then
	RED_COLOR="\033[31;1m"
	GREEN_COLOR="\033[32;1m"
	YELLOW_COLOR="\033[33;1m"
	RESET_COLOR="\033[m"

	if [ "$KISS_STYLE" != "" ]
	then
		ERROR_FORMAT="$YELLOW_COLOR"ERROR"$RESET_COLOR %s\n"
		WARNING_FORMAT="$YELLOW_COLOR"WARNING"$RESET_COLOR %s\n"
		INFO_FORMAT="$YELLOW_COLOR->$RESET_COLOR %s\n"
		PROMPT_FORMAT="%s "
	else
		ERROR_FORMAT="$RED_COLOR"XX"$RESET_COLOR %s\n"
		WARNING_FORMAT="$YELLOW_COLOR"!!"$RESET_COLOR %s\n"
		INFO_FORMAT="$GREEN_COLOR->$RESET_COLOR %s\n"
		PROMPT_FORMAT="$GREEN_COLOR<-$RESET_COLOR %s\n"
	fi
fi

# Running multiple minekisses without exploding is nice.
MINEKISS_TEMP_DIR="$MINEKISS_TEMP_DIR/$$"

mkdir -p "$MINEKISS_TEMP_DIR"
mkdir -p "$USERDATA_DIR"

trap abort INT
trap cleanup EXIT

case $1 in
	download | d) download "$2" && exit ;;
	start | s) start_version "$2" && exit ;;
	authenticate | a) account_login "$2" && exit ;;
	logout | l) account_logout "$2" && exit ;;
	select | se) account_select "$2"  && exit ;;
	accounts | ac) account_list && exit ;;
esac

if [ "$1" != "" ]
then
	error "Unrecognized command."
else
	EXECUTABLE_NAME="$(basename "$0")"
	info "$EXECUTABLE_NAME [d|s] [version]"
	info "download Verify and download a Minecraft version into the cache directory"
	info "start    Start a Minecraft version into the current drectory"
	info
	info "$EXECUTABLE_NAME [a|l|se|ac] [account]"
	info "authenticate Authenticate or refresh an account"
	info "logout       Log out off an account"
	info "select       Select an account as the default"
	info "accounts     List all available accounts"
fi
exit 0
