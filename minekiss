#! /bin/sh

# TODO: Properly manage native libraries by extracting them (https://wiki.vg/Game_Files)
# TODO: Implement maven syntax for libraries (needed for stuff like fabric and forge)
# TODO: Properly parse all library and jvm rules
# TODO: Implement authentication and offline mode
# TODO: Add some more error handling
# TODO: Properly manage legacy and pre-1.6 assets
# TODO: Find a portable way of switching Java versions or at least find a way to configure them
# TODO: Refactor everything

# Bruh
export LC_ALL="C"

OLD_STTY="$(stty -g)"

is_directory_empty() {
 ls -A $1 | grep -q .
}

get_relative_resource_path() {
 printf "$(printf "%s" "$1" | head -c 2)/$1"
}

get_resource_url() {
	printf "$RESOURCES_URL/$(get_relative_resource_path "$1")"
}

parse_libraries_from_metadata() {
	# Format: [path] [sha1sum] [url]
	# Also how the fuck do I split this.
	jq -r ".libraries[] | select((has(\"rules\") | not) or .rules[0].action == \"allow\" and .rules[0].os.name != \"osx\") | .downloads.classifiers.\"natives-linux\" // empty, .downloads.artifact // empty | \"$LIBRARIES_DIR/\" + .path + \" \" + .sha1 + \" \" + .url"
}

error() {
	printf "XX $1\n"
	exit 1
}

info() {
	printf -- "-> $1\n"
}

subinfo() {
	printf -- " -> $1\n"
}

warning() {
	printf "!! $1\n"
}

cleanup() {
	stty "$OLD_STTY"

	if is_directory_empty "$TEMP_DIR"
	then info "Cleaning up..."
	fi

	rm -rf "$TEMP_DIR"
}

download() {
	SELECTED_VERSION="$1"

	VERSION_CLIENT_FILE="$VERSIONS_DIR/$SELECTED_VERSION/$SELECTED_VERSION.jar"
	VERSION_METADATA_FILE="$VERSIONS_DIR/$SELECTED_VERSION/$SELECTED_VERSION.json"

	VERSION_MANIFEST_FILE="$CACHE_DIR/version_manifest.json"

	info "Fetching the latest version manifest..."

	mkdir -p "$(dirname "$VERSION_MANIFEST_FILE")"
	curl -s "$VERSION_MANIFEST_URL" > "$VERSION_MANIFEST_FILE" || error "Unable to fetch the latest manifest!"
	
	VERSION_METADATA_URL="$(jq -r ".versions[] | select(.id == \"$SELECTED_VERSION\").url" < "$VERSION_MANIFEST_FILE")"

	if [ "$VERSION_METADATA_URL" == "" ]
	then
		if [ -f "$VERSION_METADATA_FILE" ]
		then
			warning "Custom version detected! Its files won't be validated."
			return 0
		else
			error "Invalid version id!"
		fi
	fi

	# Metadata
	info "Validating the current version metadata..."

	# The SHA1 is for some reason only encoded into the version metadata path.
	# URL format: https://launchermeta.mojang.com/v1/packages/SHA/VERSION.json
	VERSION_METADATA_SHA1="$(basename "$(dirname "$VERSION_METADATA_URL")")"

	if ! printf "%s  %s\n" "$VERSION_METADATA_SHA1" "$VERSION_METADATA_FILE" | sha1sum -c 1>/dev/null 2>&1
	then
		subinfo "Downloading \"$(basename "$VERSION_METADATA_FILE")\"..."
		mkdir -p "$(dirname "$VERSION_METADATA_FILE")"
		curl -s "$VERSION_METADATA_URL" > "$VERSION_METADATA_FILE"
	fi

	# Client
	VERSION_CLIENT_URL="$(jq -r ".downloads.client.url" < "$VERSION_METADATA_FILE")"

	info "Validating the client jar..."

	VERSION_CLIENT_SHA1="$(jq -r ".downloads.client.sha1" < "$VERSION_METADATA_FILE")"

	if ! printf "%s  %s\n" "$VERSION_CLIENT_SHA1" "$VERSION_CLIENT_FILE" | sha1sum -c 1>/dev/null 2>&1
	then
		subinfo "Downloading \"$(basename "$VERSION_CLIENT_FILE")\"..."
		# We don't run mkdir here because the client will be downloaded in the same
		# directory of the version metadata.
		curl -s "$VERSION_CLIENT_URL" > "$VERSION_CLIENT_FILE"
	fi

	# Asset index
	info "Validating the game's asset index..."

	ASSET_INDEX_ID="$(jq -r ".assetIndex.id" < "$VERSION_METADATA_FILE")"
	ASSET_INDEX_URL="$(jq -r ".assetIndex.url" < "$VERSION_METADATA_FILE")"
	ASSET_INDEX_SHA1="$(jq -r ".assetIndex.sha1" < "$VERSION_METADATA_FILE")"

	ASSET_INDEX_FILE="$ASSETS_DIR/indexes/$ASSET_INDEX_ID.json"

	if ! printf "%s  %s\n" "$ASSET_INDEX_SHA1" "$ASSET_INDEX_FILE" | sha1sum -c 1>/dev/null 2>&1
	then
		subinfo "Downloading \"$(basename "$ASSET_INDEX_FILE")\"..."

		mkdir -p "$(dirname $ASSET_INDEX_FILE)"
		curl -s "$ASSET_INDEX_URL" > "$ASSET_INDEX_FILE"
	fi

	# TODO: Add support for the older asset indexes.
	info "Validating the game's assets..."

	if [ "$ASSET_INDEX_ID" == "pre-1.6" ] || [ "$ASSET_INDEX_ID" == "legacy" ]
	then
		error "Legacy (pre 1.6) version detected! Download stopped as legacy asset managing is not supported yet."
	fi

	CONVERTED_ASSET_INDEX="$TEMP_DIR/converted_asset_index"
	FAILED_ASSETS="$TEMP_DIR/failed_assets"

	# Le epic conversion: [le hash] [le actual path] [le game path]
	# This allows us to use the shell's own word splitting as a blazingly fast line
	# by line "parser" for our intermediate format. Maybe we could use FIFOs but I
	# think that would just make things more complicated for nothing.
	jq -r ".objects | to_entries[] | .value.hash + \" \" + \"$ASSETS_DIR/objects/\" + .value.hash[0:2] + \"/\" + .value.hash + \" \" + .key" < "$ASSET_INDEX_FILE" > "$CONVERTED_ASSET_INDEX"

	awk '{print $1 "  " $2}' < "$CONVERTED_ASSET_INDEX" | sha1sum -c 2> /dev/null | grep FAILED | cut -d ":" -f 1 > "$FAILED_ASSETS"

	grep -f "$FAILED_ASSETS" < "$CONVERTED_ASSET_INDEX" | while read -r ASSET_SHA1 ASSET_FILE_PATH ASSET_GAME_PATH
	do
		subinfo "Downloading \"$ASSET_GAME_PATH\"..."
		mkdir -p "$(dirname "$ASSET_FILE_PATH")"
		curl -s "$(get_resource_url "$ASSET_SHA1")" > "$ASSET_FILE_PATH"
	done

	# Libaries
	info "Validating the game's libraries..."

	CONVERTED_LIBRARY_INDEX="$TEMP_DIR/converted_library_index"
	FAILED_LIBS="$TEMP_DIR/failed_libs"

	parse_libraries_from_metadata < "$VERSION_METADATA_FILE" > "$CONVERTED_LIBRARY_INDEX"

	awk '{print $2 "  " $1}' < "$CONVERTED_LIBRARY_INDEX" | sha1sum -c 2> /dev/null | grep FAILED | cut -d ":" -f 1 > "$FAILED_LIBS"

	# TODO: Decompress properly the native libraries into a specialized directory.
	grep -f "$FAILED_LIBS" < "$CONVERTED_LIBRARY_INDEX" | while read -r LIBRARY_FILE LIBRARY_SHA1 LIBRARY_URL
	do
		LIBRARY_FILE_NAME="$(basename "$LIBRARY_FILE")"
		mkdir -p "$(dirname "$LIBRARY_FILE")"

		subinfo "Downloading \"$LIBRARY_FILE_NAME\"..."
			curl -s "$LIBRARY_URL" > "$LIBRARY_FILE"
	done
}

start_version() {
	SELECTED_VERSION="$1"

	VERSION_CLIENT_FILE="$VERSIONS_DIR/$SELECTED_VERSION/$SELECTED_VERSION.jar"
	VERSION_METADATA_FILE="$VERSIONS_DIR/$SELECTED_VERSION/$SELECTED_VERSION.json"

	download "$SELECTED_VERSION"

	CLASSPATH="$(parse_libraries_from_metadata < "$VERSION_METADATA_FILE" | awk '{print $1}' | tr "\n" ":")"
	CLASSPATH="$CLASSPATH$VERSION_CLIENT_FILE"

	MAIN_CLASS="$(jq -r ".mainClass" < "$VERSION_METADATA_FILE")"
	ASSET_INDEX_ID="$(jq -r ".assetIndex.id" < "$VERSION_METADATA_FILE")"

	# TODO: Find a way to manage stuff like resolution which is behind a rule.
	# TODO: Format all arguments.
	GAME_ARGUMENTS="$(echo $(jq -r "if has(\"arguments\") and (.arguments | has(\"game\")) then (.arguments.game[] | strings) else .minecraftArguments end" < "$VERSION_METADATA_FILE" | tr "\n" " "))"
	GAME_ARGUMENTS="$(printf "%s" "$GAME_ARGUMENTS" | sed "s|"'${version_name}'"|$SELECTED_VERSION|")"
	GAME_ARGUMENTS="$(printf "%s" "$GAME_ARGUMENTS" | sed "s|"'${assets_root}'"|$ASSETS_DIR|")"
	GAME_ARGUMENTS="$(printf "%s" "$GAME_ARGUMENTS" | sed "s|"'${assets_index_name}'"|$ASSET_INDEX_ID|")"
	GAME_ARGUMENTS="$(printf "%s" "$GAME_ARGUMENTS" | sed "s|"'${version_type}'"|$(jq -r .type < "$VERSION_METADATA_FILE")|")"

	# TODO: Find out if there's a better way to switch Java runtimes.
	if [ "$JAVA" == "" ]
	then
		JAVA="java"
	fi

	# TODO: Read metadata from the instance to choose the right Java version.
	"$JAVA" -cp "$CLASSPATH" "$MAIN_CLASS" $GAME_ARGUMENTS
}

add_user() {
	printf "Email address (or if legacy, username): "
	read -r EMAIL_ADDRESS

	# We do this because we don't want to show the password being written.
	stty -echo
	printf "Password: "
	read -r PASSWORD
	stty echo
	printf "\n"
}

authenticate() {
	if [ ! -f "$USERDATA_DIR/client_id" ]
	then
		info "Client id file missing, generating a new client id..."
		# Mhh, should I make this a read-only file?
		(umask 077; uuidgen > "$USERDATA_DIR/client_id")
	fi
}

# Configuration

if [ "$VERSION_MANIFEST_URL" == "" ]
then
	VERSION_MANIFEST_URL="https://launchermeta.mojang.com/mc/game/version_manifest.json"
fi

if [ "$RESOURCE_URL" == "" ]
then
	RESOURCES_URL="http://resources.download.minecraft.net"
fi

if [ "$XDG_CACHE_HOME" == "" ]
then
	XDG_CACHE_HOME="$HOME/.cache"
fi

CACHE_DIR="$XDG_CACHE_HOME/minekiss"

if [ "$XDG_DATA_HOME" == "" ]
then
	XDG_DATA_HOME="$HOME/.local/share"
fi

USERDATA_DIR="$XDG_DATA_HOME/minekiss"

if [ "$ASSETS_DIR" == "" ]
then
	ASSETS_DIR="$CACHE_DIR/assets"
fi

if [ "$LIBRARIES_DIR" == "" ]
then
	LIBRARIES_DIR="$CACHE_DIR/libraries"
fi

if [ "$VERSIONS_DIR" == "" ]
then
	VERSIONS_DIR="$CACHE_DIR/versions"
fi

if [ "$TEMP_DIR" == "" ]
then
	TEMP_DIR="/tmp/minekiss"
fi

mkdir -p "$TEMP_DIR"
mkdir -p "$USERDATA_DIR"

trap exit INT
trap cleanup EXIT

if [ "$1" == "download" ]
then
	if [ "$2" != "" ]
	then
		download "$2" && info "Download finished."
	else
		printf "Usage: $0 download ID\n"
		printf "Downloads and verifies the specified mincraft version into minekiss' cache directory.\n"
	fi
	exit 0
fi

if [ "$1" == "start" ]
then
	if [ "$2" != "" ]
	then
		start_version "$2"
	else
		printf "Usage: $0 start ID\n"
		printf "start: Runs the specified minecraft version (if dowloaded) into the current drectory.\n"
	fi
	exit 0
fi

if [ "$1" == "user" ]
then
	if [ "$2" == "add" ]
	then
		add_user "$3"
	else
		printf "Usage: $0 user add/remove/list\n"
		printf "user: manage the current user profiles.\n"
	fi
	exit 0
fi

if [ "$1" != "" ]
then
	printf "Unrecognized command: \"$1\"\n"
else
	printf "minekiss - A simple minecraft launcher written entirely in POSIX shell.\n"
	printf "Available commands:\n"
	printf " - download: download and verify the specified minecraft version into minekiss' cache directory.\n"
	printf " - start: run the specified minecraft version (if dowloaded) into the current drectory.\n"
	printf " - user: manage the current user profiles.\n"
fi
exit 0
